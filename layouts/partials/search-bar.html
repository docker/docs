<!-- search button, mobile (link off to the search page for now) -->
<a href="/search" class="sm:hidden">
  <span class="icon-svg">{{ partialCached "icon" "search" "search" }}</span>
</a>
<!-- search button -->
<div
  x-ref="searchBarRef"
  x-data="{ open: false }"
  @click.outside="open = false;"
  @keyup.escape.window="open = false"
  id="search-bar"
  class="relative hidden min-w-0 items-center rounded-sm bg-white/10 p-2 sm:flex sm:w-full xl:w-[400px]"
>
  {{- with resources.Get "images/search-ai.svg" -}}
    {{ .Content | safeHTML }}
  {{- end -}}
  <input
    x-ref="searchBarInput"
    type="search"
    id="search-bar-input"
    @focus="open = true;"
    @keyup.enter.prevent="window.location.href = '/search/?q=' + $event.target.value;"
    @keyup.escape.prevent="open = false;"
    @keydown.window="(e) => {
          switch(e.key) {
          case 'k':
            if (e.metaKey || e.ctrlKey) {
              e.preventDefault();
              $el.focus();
            }
            break;
          }
        }"
    class="min-w-0 flex-grow bg-transparent px-2 text-white outline-hidden placeholder:text-white"
    placeholder="Search"
    tabindex="0"
  />
  <div
    x-cloak
    :class="open && 'hidden'"
    class="hidden items-center rounded-sm border border-white px-1 text-sm lg:flex"
  >
    <div class="-mt-0.5">
      <span x-show="navigator.platform == 'MacIntel'" class="icon-svg icon-sm"
        >{{ partialCached "icon" "keyboard_command_key" "keyboard_command_key" }}</span
      >
      <span x-show="navigator.platform != 'MacIntel'" class="icon-svg icon-sm"
        >{{ partialCached "icon" "keyboard_control_key" "keyboard_control_key" }}</span
      >
    </div>
    <span>K</span>
  </div>
  <div x-cloak :class="open || 'hidden'">
    <button
      @click="$refs.searchBarInput.value = ''; open = false"
      class="text-white hover:text-white"
    >
      <span class="icon-svg">{{ partialCached "icon" "close" "close" }}</span>
    </button>
  </div>
  <div
    x-show="open"
    x-cloak
    id="search-dropdown"
    class="bg-background-light dark:bg-background-dark fixed z-50 w-full max-w-xl rounded-sm px-6 py-4 shadow-lg"
  >
    <div id="search-bar-results">
      {{- $emptyState := `<div class="p-2 text-gray-500 dark:text-gray-400">Start typing to search… or try <button @click="open=false" class="open-kapa-widget link">Ask AI</button></div>` }}
      {{- $emptyState | safe.HTML }}
      <!-- results -->
    </div>
  </div>
  <script type="module">
    window.addEventListener("load", async function () {
      const pagefind = await import("/pagefind/pagefind.js");
      await pagefind.options({
        ranking: {
          termFrequency: 0.2,
          pageLength: 0.75,
          termSaturation: 1.4,
          termSimilarity: 6.0,
        },
      });

      const searchBarInput = document.querySelector("#search-bar-input");
      const searchBarResults = document.querySelector("#search-bar-results");
      const searchDropdown = document.querySelector("#search-dropdown");
      const searchBar = document.querySelector("#search-bar");

      // Function to update dropdown position
      function updateDropdownPosition() {
        if (!searchBar || !searchDropdown || searchDropdown.style.display === 'none') return;
        
        const rect = searchBar.getBoundingClientRect();
        const dropdownHeight = searchDropdown.offsetHeight || 300;
        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;
        
        // Calculate horizontal position and width
        let leftPos = rect.left;
        let width = Math.min(rect.width * 1.5, 600); // Make dropdown wider than search bar, max 600px
        
        // Ensure dropdown doesn't go off right edge of screen
        if (leftPos + width > viewportWidth - 20) {
          leftPos = viewportWidth - width - 20;
        }
        
        // Ensure dropdown doesn't go off left edge
        if (leftPos < 20) {
          leftPos = 20;
        }
        
        // Check if there's enough space below
        const spaceBelow = viewportHeight - rect.bottom;
        const spaceAbove = rect.top;
        
        searchDropdown.style.left = `${leftPos}px`;
        searchDropdown.style.width = `${width}px`;
        searchDropdown.style.maxWidth = '600px';
        searchDropdown.style.minWidth = `${rect.width}px`;
        
        if (spaceBelow < dropdownHeight && spaceAbove > spaceBelow) {
          // Position above the search bar
          searchDropdown.style.bottom = `${viewportHeight - rect.top + 8}px`;
          searchDropdown.style.top = 'auto';
          searchDropdown.style.maxHeight = `${Math.min(spaceAbove - 20, 400)}px`;
        } else {
          // Position below the search bar
          searchDropdown.style.top = `${rect.bottom + 8}px`;
          searchDropdown.style.bottom = 'auto';
          searchDropdown.style.maxHeight = `${Math.min(spaceBelow - 20, 400)}px`;
        }
        
        // Ensure results area is scrollable if needed
        searchBarResults.style.maxHeight = 'calc(100% - 20px)';
        searchBarResults.style.overflowY = 'auto';
      }

      // Update position when dropdown becomes visible
      const observer = new MutationObserver(function(mutations) {
        mutations.forEach(function(mutation) {
          if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
            const isVisible = searchDropdown.style.display !== 'none' && !searchDropdown.classList.contains('hidden');
            if (isVisible) {
              updateDropdownPosition();
            }
          }
        });
      });
      
      observer.observe(searchDropdown, { 
        attributes: true, 
        attributeFilter: ['style', 'class'] 
      });

      // Update position on scroll and resize
      window.addEventListener('scroll', updateDropdownPosition);
      window.addEventListener('resize', updateDropdownPosition);
      
      // Update position when search input is focused
      searchBarInput.addEventListener('focus', () => {
        setTimeout(updateDropdownPosition, 0);
      });

      // Existing search functionality
      async function search(e) {
        const query = e.target.value;
        if (query === "") {
          searchBarResults.innerHTML = `{{ $emptyState | safe.HTML }}`;
          return;
        }
        const search = await pagefind.debouncedSearch(query);
        if (search === null) {
          return;
        } else {
          const resultsLength = search.results.length
          const resultsData = await Promise.all(search.results.slice(0, 5).map(r => r.data()));
          const results = resultsData.map((item, index) => ({...item, index: index + 1}));

          if (query) {
            searchBarResults.classList.remove("hidden");
          } else {
            searchBarResults.classList.add("hidden");
          }

          let resultsHTML = `<div class="p-2 text-gray-400 dark:text-gray-500">${resultsLength} results</div>`;
          resultsHTML += results
            .map((item) => {
              return `<div class="p-2">
              <div class="flex flex-col">
                <a class="link" href="${item.url}" data-query="${query}" data-index="${item.index}">${item.meta.title}</a>
                <p class="text-black dark:text-white overflow-hidden">…${item.excerpt}…</p>
              </div>
              </div>`;
            })
            .join("");
          if (resultsLength > 5) {
            resultsHTML += `<div class="w-fit ml-auto px-4 py-2"><a href="/search/?q=${query}" class="link">Show all results</a></div>`;
          }

          searchBarResults.innerHTML = resultsHTML;
          
          // Update position after results are loaded
          setTimeout(updateDropdownPosition, 0);
        }
      }

      searchBarInput.addEventListener("input", search);

      // Event delegation for tracking link clicks
      if (window.heap !== undefined) {
        searchBarResults.addEventListener('click', function (event) {
          if (event.target.tagName === 'A' && event.target.closest('.link')) {
            const searchQuery = event.target.getAttribute('data-query');
            const resultIndex = event.target.getAttribute('data-index');
            const url = new URL(event.target.href);
            const properties = {
              docs_search_target_path: url.pathname,
              docs_search_target_title: event.target.textContent,
              docs_search_query_text: searchQuery,
              docs_search_target_index: resultIndex,
              docs_search_source_path: window.location.pathname,
              docs_search_source_title: document.title,
            };
            heap.track("Docs - Search - Click - Result Link", properties);
          }
        });
      }
    });
  </script>
</div>
