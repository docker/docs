---
title: "Docker Reference Architecture: Development Pipeline Best Practices Using Docker EE"
id: 1885
draftstate: inactive
deleted: false
layout: docs
permalink: /kb/1885/
source: https://success.docker.com/@api/deki/pages/1885/contents
tags:
- tag: "article:reference"
- tag: "product:datacenter"
- tag: "stage:reviewed"
- tag: "testedon:cse-1.13.1-cs1"
- tag: "testedon:docker-17.03"
- tag: "testedon:dtr-2.2.1"
- tag: "testedon:ucp-2.1.0"
---
{% raw %}
<script type="text/javascript">
 /*<![CDATA[*/
var authorByline = "Lee Namba";
/*]]>*/
</script>
<div class="mt-section" id="section_1" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Introduction">
 </span>
 <h2 id="1-0">
  Introduction
 </h2>
 <p>
  The Docker Container as a Service (CaaS) platform delivers a secure, managed application environment for developers to build, ship, and run enterprise applications and custom business processes. In the “build” part of this process, there are design and organizational decisions that need to be made.
 </p>
</div>
<div class="mt-section" id="section_2" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="What_You_Will_Learn">
 </span>
 <h2 id="1-1">
  What You Will Learn
 </h2>
 <p>
  In an enterprise, there can be hundreds or even thousands of applications developed by in-house and outsourced teams. Application technology stacks can vary from a simple Excel macro, to multi-tier J2EE, all the way to clusters of elastic microservices deployed on a hybrid cloud. Applications are also deployed to several heterogeneous environments (development, test, UAT, staging, production, etc.), each of which can have very different requirements. Packaging an application in a container with its configuration and dependencies guarantees that the application will always work as designed in any environment. The purpose of this document is to provide you with typical development pipeline workflows as well as best practices for structuring your development process using Docker EE (formerly known as Docker Datacenter).
 </p>
 <p>
  This document is divided into two main parts. In the first part, you will learn about the overall development pipeline, how Docker EE integrates with existing build systems, and different workflows (developer, CI/CD, operations). In the second part, you will learn best practices for migrating existing applications to Docker such as what applications to Dockerize, what components to put in images, what configuration to put in containers, where to put different types of configuration, and how to store assets for building images and configuration in version control.
 </p>
</div>
<div class="mt-section" id="section_3" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Development_Pipeline_Overview">
 </span>
 <h2 id="1-2">
  Development Pipeline Overview
 </h2>
 <p>
  This section discusses the general workflow and organization of the development pipeline. It also covers the specific developer, CI/CD, and operations workflows and environments.
 </p>
 <div class="mt-section" id="section_4" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="General_Organization">
  </span>
  <h3 id="2-0">
   General Organization
  </h3>
  <p>
   A typical enterprise has separate development and operations teams and may have some level of DevOps adoption. In general, operations teams are responsible for delivering and supporting the infrastructure up to the operating systems and even middleware components. Development teams are responsible for building and maintaining the applications. There is also some type of continuous integration (CI) for automated build and testing as well as continuous delivery (CD) for deploying versions to the different environments.
  </p>
  <p>
   <img alt="General Organization" class="internal" src="/kb/images/1885-0.png"/>
  </p>
 </div>
 <div class="mt-section" id="section_5" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="General_Workflow">
  </span>
  <h3 id="2-1">
   General Workflow
  </h3>
  <p>
   A typical CI/CD workflow is shown in the following diagram:
  </p>
  <p>
   <img alt="General Workflow" class="internal" src="/kb/images/1885-1.png"/>
  </p>
  <p>
   It starts on the left-hand side with development teams building applications. A CI/CD system then runs unit tests, packages the applications and builds Docker images on the Docker Universal Control Plane (UCP). If all tests pass, the images can be signed using
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/content-trust/" rel="external nofollow" target="_blank">
    Docker Content Trust
   </a>
   and shipped to Docker Trusted Registry (DTR). The images can then be run in other non-production environments for further testing. If the images pass these testing environments, they can be signed again and then deployed by the operations team to the production environment.
  </p>
 </div>
 <div class="mt-section" id="section_6" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="UCP_Clusters">
  </span>
  <h3 id="2-2">
   UCP Clusters
  </h3>
  <p>
   Enterprises typically have separate production and non-production UCP clusters as previously shown. This is a natural fit with existing infrastructure organization and responsibilities. Enterprises typically have a production environment with higher security requirements, restrained operator access, a high-performance infrastructure, high-availability configurations, and full disaster recovery with multiple data centers. The non-production environment has different requirements with the main goal being testing and qualifying applications for production. The interface between the non-production and production clusters is DTR.
  </p>
  <p>
   The question of whether to have a separate UCP cluster per availability zone or have one "stretched cluster" mainly depends on the network latency and bandwidth between availability zones. There could also be existing infrastructure and disaster recovery considerations to take into account.
  </p>
  <p>
   In an enterprise environment where there can be hundreds of teams building and running applications a best practice is to separate the build from the run resources. By doing this, the image building process does not affect the performance or availability of the running containers/services.
  </p>
  <p>
   There are two common methods of building images using Docker EE:
  </p>
  <ul>
   <li>
    <strong>
     Developers build images on their own machines then push them to DTR
    </strong>
    - This is suitable if there is no CI/CD system and no dedicated build cluster. Developers have the freedom to push different images to DTR.
   </li>
   <li>
    <strong>
     A CI/CD process builds images on a build cluster and pushes them to DTR
    </strong>
    - This is suitable if an enterprise wants to control the quality of the images pushed into DTR. Developers commit Dockerfiles to version control. They can then be analyzed and controlled for adherence to corporate standards before the CI/CD system builds the images, tests them, and pushes them to DTR. In this case CI/CD agents should be run directly on the dedicated build nodes.
   </li>
  </ul>
  <blockquote>
   <p>
    <strong>
     Note:
    </strong>
    In the CI/CD job it is important to insure that images are built and pushed from the same Docker node so there is no ambiguity in the image that is pushed to DTR.
   </p>
  </blockquote>
 </div>
 <div class="mt-section" id="section_7" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="DTR_Clusters">
  </span>
  <h3 id="2-3">
   DTR Clusters
  </h3>
  <p>
   Unlike the separate production and non-production UCP clusters, enterprises commonly have a single master DTR cluster. This allows enforcement of enterprise processes such as
   <a class="link-https" href="https://docs.docker.com/docker-cloud/builds/image-scan/" rel="external nofollow" target="_blank">
    Security Scanning
   </a>
   in a centralized place. If pulling images from globally distributed locations takes too long then you can use the
   <a class="link-https" href="https://docs.docker.com/datacenter/dtr/2.2/guides/admin/configure/deploy-a-cache/" rel="external nofollow" target="_blank">
    DTR Content Cache
   </a>
   feature to create local caches.
  </p>
  <blockquote>
   <p>
    <strong>
     Note:
    </strong>
    Policy enforcement on
    <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/content-trust/" rel="external nofollow" target="_blank">
     image signing
    </a>
    will not currently work if you have your DTR in a separate cluster from UCP.
   </p>
  </blockquote>
 </div>
</div>
<div class="mt-section" id="section_8" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Developer_Workflow">
 </span>
 <h2 id="1-3">
  Developer Workflow
 </h2>
 <p>
  Developers and application teams usually use different repositories within the organization to develop, deploy, and test their applications. This section discusses the following diagram of a typical developer workflow using Docker EE as well as their interactions with the repositories:
 </p>
 <p>
  <img alt="Developer Workflow" class="internal" src="/kb/images/1885-2.png"/>
 </p>
 <p>
  A typical developer workflow follows these steps:
 </p>
 <ol>
  <li>
   <strong>
    Develop Locally
   </strong>
   - On the developer's machine or environment the developer locally builds images, run containers, and test their containers. There are several types of files and their respective repositories that are used to build Docker images.
   <ul>
    <li>
     <strong>
      Version Control
     </strong>
     - This is used mainly for text-based files such as Dockerfiles,
     <code>
      docker-compose.yml
     </code>
     , and configuration files. Small binaries can also kept in the same version control. Examples of version control are git, svn, Team Foundation Server, VSTS, and Clear Case.
    </li>
    <li>
     <strong>
      Repository Manager
     </strong>
     - These hold larger binary files such as Maven/Java, npm, NuGet, and RubyGems. Examples include Nexus, Artifactory, and Archiva.
    </li>
    <li>
     <strong>
      Package Repository
     </strong>
     - These hold packaged applications specific to an operating system such as CentOS, Ubuntu, and Windows Server. Examples include yum, apt-get, and PackageManagement.
     <br/>
     After building an image, developers can run the container using the environment variables and configuration files for their environments. They can also run several containers together described in a
     <code>
      docker-compose.yml
     </code>
     file and test their application.
    </li>
   </ul>
  </li>
  <li>
   <strong>
    Push Images
   </strong>
   - Once an image has been tested locally, it can be pushed to the Docker Trusted Registry. The developer must have an account on DTR and can push to a registry on their user account for testing on UCP. For example:
   <code>
    docker push dtr.example.com/kathy.seaweed/apache2:1.0
   </code>
  </li>
  <li>
   <strong>
    Deploy on UCP
   </strong>
   - The developer might want to do a test deployment on an integration environment on UCP in the case where the development machine does not have the ability or access to all the resources to run the entire application. They might also want to test whether the application scales properly if it's deployed as a service. In this case the developer would use
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/access-ucp/cli-based-access/" rel="external nofollow" target="_blank">
    CLI-based access
   </a>
   to
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/applications/deploy-app-cli/" rel="external nofollow" target="_blank">
    deploy the application on UCP
   </a>
   .
   <br/>
   Use
   <code>
    $ eval $(&lt;env.sh)
   </code>
   to point the Docker client to UCP. Then run the following commands:
   <pre>
<code>$ docker run -dit --name apache2 dtr.example.com/kathy.seaweed/apache2:1.0 
$ docker-compose --project-name wordpress up -d 
$ docker service create --name apache2 dtr.example.com/kathy.seaweed/apache2:1.0</code></pre>
  </li>
  <li>
   <strong>
    Test the application
   </strong>
   - The developer can then test the deployed application on UCP from his machine to validate the configuration of the test environment.
  </li>
  <li>
   <strong>
    Commit to Version Control
   </strong>
   - Once the application is tested on UCP the developer can commit the files used to create the application, its images, and its configuration to version control. This commit triggers the CI/CD workflow.
  </li>
 </ol>
 <div class="mt-section" id="section_9" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Developer_Environment_and_Tools">
  </span>
  <h3 id="2-4">
   Developer Environment and Tools
  </h3>
  <p>
   A developer's machine should have an edition of Docker (
   <a class="link-https" href="https://docs.docker.com/docker-for-windows/" rel="external nofollow" target="_blank">
    Windows
   </a>
   ,
   <a class="link-https" href="https://docs.docker.com/docker-for-mac/" rel="external nofollow" target="_blank">
    Mac
   </a>
   , or
   <a class="link-https" href="https://docs.docker.com/engine/installation/linux/" rel="external nofollow" target="_blank">
    Linux
   </a>
   ) installed on it. The installation provides
   <a class="link-https" href="https://docs.docker.com/engine/userguide/intro/" rel="external nofollow" target="_blank">
    Docker Engine
   </a>
   ,
   <a class="link-https" href="https://docs.docker.com/engine/reference/commandline/cli/" rel="external nofollow" target="_blank">
    Docker CLI client
   </a>
   ,
   <a class="link-https" href="https://docs.docker.com/compose/overview/" rel="external nofollow" target="_blank">
    Docker Compose
   </a>
   , and
   <a class="link-https" href="https://docs.docker.com/notary/getting_started/" rel="external nofollow" target="_blank">
    Docker Notary command line
   </a>
   .
  </p>
  <p>
   In some enterprises, the version of the operating system used on developer machines is older and not compatible with Docker for Windows or Mac. In this case
   <a class="link-https" href="https://docs.docker.com/toolbox/overview/" rel="external nofollow" target="_blank">
    Docker Toolbox
   </a>
   can be used.
  </p>
  <div class="mt-section" id="section_10" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="IDE">
   </span>
   <h4 id="3-0">
    IDE
   </h4>
   <p>
    Docker versions do not provide a native IDE for developing with Docker. The primary interface is the command line API. However, most leading IDEs (NetBeans, Eclipse, IntelliJ, Visual Studio) have some support for Docker through plugins or add-ons. Our
    <a class="link-https" href="https://github.com/docker/labs/tree/master/developer-tools" rel="external nofollow" target="_blank">
     labs
    </a>
    contain tutorials on how to set-up and use common developer tools and programming languages with Docker.
   </p>
   <blockquote>
    <p>
     <strong>
      Tip: Optimizing images sizes.
     </strong>
     If an image size becomes too large, a quick way to identify where possible optimizations are is to use the
     <code>
      docker history &lt;image&gt;
     </code>
     command. It will tell you which lines in the Dockerfile added what size to the image.
    </p>
   </blockquote>
  </div>
  <div class="mt-section" id="section_11" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Docker_Client_CLI_Contexts">
   </span>
   <h4 id="3-1">
    Docker Client CLI Contexts
   </h4>
   <p>
    When working with Docker EE and the Docker command line, it is important to keep in mind the context that the command is running in.
   </p>
   <ul>
    <li>
     <strong>
      Local Docker Engine
     </strong>
     - This is the main context used for development of Dockerfiles and testing locally on the developer's machine.
    </li>
    <li>
     <strong>
      Remote UCP CLI
     </strong>
     -
     <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/access-ucp/cli-based-access/" rel="external nofollow" target="_blank">
      CLI-based access
     </a>
     is used for building and running applications on a UCP cluster.
    </li>
    <li>
     <strong>
      UCP GUI
     </strong>
     - The Docker EE web user interface provides an alternative to the CLI.
    </li>
    <li>
     <strong>
      Remote UCP node
     </strong>
     - Sometimes it can be useful for debugging to directly connect to a node on the UCP cluster. In this case, SSH can be used and the commands are executed on the Docker Engine of the node.
    </li>
   </ul>
   <p>
    A quick way to see which context you are in is by doing an
    <code>
     export
    </code>
    command. If you have a
    <code>
     DOCKER_HOST
    </code>
    environment variable set, then you have most likely configured your UNIX session to use the UCP client bundle, meaning all Docker commands are executed on the UCP cluster.
   </p>
  </div>
 </div>
</div>
<div class="mt-section" id="section_12" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="CI.2FCD_Workflow">
 </span>
 <h2 id="1-4">
  CI/CD Workflow
 </h2>
 <p>
  A CI/CD platform uses different systems within the organization to automatically build, deploy, and test applications. This section discusses a typical CI/CD workflow using Docker EE and their interactions with those repositories as showing in the following illustration:
 </p>
 <p>
  <img alt="CI/CD Workflow" class="internal" src="/kb/images/1885-3.png"/>
 </p>
 <p>
  A typical CI/CD workflow follows these steps:
 </p>
 <ol>
  <li>
   <strong>
    Build Application
   </strong>
   — A change to the version control of the application triggers a build by the CI Agent. A build container is started and passed parameters specific to the application. The container can run on a separate Docker host or on UCP. The container obtains the source code from version control, runs the commands of the application's build tool, and finally pushes the resulting artifact to a Repository Manager.
  </li>
  <li>
   <strong>
    Build Image
   </strong>
   — The CI Agent pulls the Dockerfile and associated files to build the image from version control. The Dockerfile is setup so that the artifact built in the previous step is copied into the image. The resulting image is pushed to DTR. If
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/content-trust/" rel="external nofollow" target="_blank">
    Docker Content Trust
   </a>
   has been enabled and
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/content-trust/manage-trusted-repositories/" rel="external nofollow" target="_blank">
    Notary
   </a>
   has been installed, then the image is signed with the CI/CD signature.
  </li>
  <li>
   <strong>
    Deploy Application
   </strong>
   — The CI Agent can pull a run-time configuration from version control (e.g.
   <code>
    docker-compose.yml
   </code>
   + environment-specific configuration files) and use them to
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/applications/deploy-app-cli/" rel="external nofollow" target="_blank">
    deploy the application on UCP
   </a>
   via the
   <a class="link-https" href="https://docs.docker.com/datacenter/ucp/2.0/guides/access-ucp/cli-based-access/" rel="external nofollow" target="_blank">
    CLI-based access
   </a>
   .
  </li>
  <li>
   <strong>
    Test Application
   </strong>
   — The CI Agent deploys a test container to test the application deployed in the previous step. If the all of the tests pass, then the image can be signed with a QA signature by pulling and pushing the image to DTR. This push triggers the Operations workflow.
  </li>
 </ol>
 <blockquote>
  <p>
   <strong>
    Tip:
   </strong>
   The CI Agent can also be Dockerized, however, since it runs Docker commands, it needs access to the host's Docker Engine. This can be done by mounting the host's Docker socket, for example:
  </p>
 </blockquote>
 <pre>
<code>docker run --rm -it --name ciagent \
  -v /var/run/docker.sock:/var/run/docker.sock \
  ciagent:1
</code></pre>
 <blockquote>
  <p>
   <strong>
    Tip:
   </strong>
   Use Docker images as build caches. When applications are built in a container, often there is a need to download dependencies to compile the application. An enterprise cache or proxy such as Nexus is also used to speed this up. To speed the build up even further you can create a "build base image" with pre-loaded common dependencies from which the build container can inherit. This avoids mounting shared volumes to cache the dependencies between build containers.
  </p>
 </blockquote>
 <div class="mt-section" id="section_13" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="CI.2FCD_Environment_and_Tools">
  </span>
  <h3 id="2-5">
   CI/CD Environment and Tools
  </h3>
  <p>
   The nodes of the CI/CD environment where Docker is used to build applications or images should have a CS Engine installed. The nodes can be labelled "build" to create a separate cluster.
  </p>
  <p>
   There are many CI/CD software systems available (Jenkins, Visual Studio, Team City, etc). Most of the leading systems have some support for Docker through plugins or add-ons. However, to ensure the most flexibility in creating CI/CD workflows, it is recommended that you use the native Docker CLI or rest API for building images or deploying containers/services.
  </p>
 </div>
</div>
<div class="mt-section" id="section_14" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Operations_Workflow">
 </span>
 <h2 id="1-5">
  Operations Workflow
 </h2>
 <p>
  The operations workflow usually consists of two parts. It starts at the beginning of the entire development pipeline creating base images for development teams to use, and it ends with pulling and deploying the production ready images from the developer teams. The workflow for creating base images is the same as the developer workflow, so it is not shown here. However, the following diagram illustrates a typical Operations workflow for deploying images in production:
 </p>
 <p>
  <img alt="Ops Workflow" class="internal" src="/kb/images/1885-4.png"/>
 </p>
 <p>
  A typical operations workflow follows these steps:
 </p>
 <ol>
  <li>
   <p>
    <strong>
     Deploy Application
    </strong>
    — The deployment to production can be triggered automatically via a change to version control for the application or it can be triggered by operations. It can also be executed manually or done by a CI/CD agent.
    <br/>
    A tag of the deployment configuration files specific to the production environment is pulled from version control. This includes a
    <code>
     docker-compose
    </code>
    file or scripts which deploy the services as well as configuration files. Secrets such as passwords or certificates that are specific to production environments should be added or updated. Docker 17.03 (and Docker Engine 1.13) contains native secrets management. The CD agent can then deploy the production topology in UCP.
   </p>
  </li>
  <li>
   <p>
    <strong>
     Test Application
    </strong>
    — The CD Agent deploys a test container to test the application deployed in the previous step. If all of the tests pass, then the application is ready to handle production load.
   </p>
  </li>
  <li>
   <p>
    <strong>
     Load Balancing
    </strong>
    — Depending on the deployment pattern (Big Bang, Rolling, Canary, Blue Green, etc.), an external load balancer, DNS server, or router is reconfigured to send all or part of the requests to the newly deployed application. The older version of the application can remained deployed in case of the need to rollback. Once the new application is deemed stable, the older version can be removed.
   </p>
  </li>
 </ol>
 <div class="mt-section" id="section_15" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Enterprise_Base_Images">
  </span>
  <h3 id="2-6">
   Enterprise Base Images
  </h3>
  <p>
   The Operations team will usually build and maintain “base images.” They typically contain the OS, middleware, and tooling to enforce enterprise policies. They might also contain any enterprise credentials used to access repositories or license servers. The development teams can then inherit from these base images by using the keyword
   <code>
    FROM
   </code>
   in their Dockerfile and then add their application specific components, applications, and configuration to their own application images.
  </p>
  <blockquote>
   <p>
    <strong>
     Tip:
    </strong>
    Squash function. Since the base images do not change that often and are widely used within an organization, minimizing their size is very important. You can use
    <code>
     docker build --squash -t &lt;image&gt; .
    </code>
    to create only one layer and optimize the size of the image. You will lose the ability modify, so this is recommended for base images and not necessarily for application images which change often.
   </p>
  </blockquote>
 </div>
 <div class="mt-section" id="section_16" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Production_Environment">
  </span>
  <h3 id="2-7">
   Production Environment
  </h3>
  <p>
   The nodes of the production environment should have CS Engine installed. For more guidelines and best practices around installing and configuring Docker EE for production please refer to
   <a href="https://success.docker.com/Architecture/Docker_Reference_Architecture%3A_Docker_EE_Best_Practices_and_Design_Considerations" rel="internal">
    Docker EE Design and Best Practices
   </a>
   . For best practices around security and Docker EE for production please refer to
   <a href="https://success.docker.com/Architecture/Docker_Reference_Architecture%3A_Securing_Docker_EE_and_Security_Best_Practices" rel="internal">
    Securing Docker EE and Security Best Practices
   </a>
   .
  </p>
 </div>
</div>
<div class="mt-section" id="section_17" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Dockerizing_Applications_in_the_Enterprise">
 </span>
 <h2 id="1-6">
  Dockerizing Applications in the Enterprise
 </h2>
 <p>
  In this section, best practices for migrating existing applications to Docker are explained. It starts with high-level decisions such as what applications to Dockerize and then moves on to more detailed decisions such as what components to put in images, what configuration to put in containers, where to put different types of configuration, and finally how to store assets for building images and configuration in version control.
 </p>
 <div class="mt-section" id="section_18" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="What_Applications_to_Dockerize.3F">
  </span>
  <h3 id="2-8">
   What Applications to Dockerize?
  </h3>
  <p>
   Deciding which components of an application to Dockerize depends on the difficulty of Dockerizing the component versus the potential gains in speed, portability, compute density, etc. There are several ways to build Docker images, including:
  </p>
  <ul>
   <li>
    From a Dockerfile
   </li>
   <li>
    By directly modifying a running container and then saving the changes to an image
   </li>
  </ul>
  <p>
   The preferred way is to build images from a Dockerfile so that the images are always reproducible. Another advantage is that Dockerfiles can be put under version control. However, with some components, this approach is too difficult. The following sections describe, in order of increasing difficulty, different categories of components and approaches for Dockerizing them.
  </p>
  <div class="mt-section" id="section_19" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Stateless">
   </span>
   <h4 id="3-2">
    Stateless
   </h4>
   <p>
    In general components which are stateless are the easiest to Dockerize because there is no need to take into account persistent data such as with databases or a shared filesystem. This is also a general best practice for microservices and allows them to scale easier as each new instance can receive requests without any synchronization of state.
   </p>
   <p>
    Some examples of these are:
   </p>
   <ul>
    <li>
     <strong>
      Web servers with static resources
     </strong>
     — Apache, Nginx, IIS
    </li>
    <li>
     <strong>
      Application servers with stateless applications
     </strong>
     — Tomcat, nodeJS, JBoss, Symphony, .NET
    </li>
    <li>
     <strong>
      Microservices
     </strong>
     — Spring Boot, Play
    </li>
    <li>
     <strong>
      Tools
     </strong>
     — Maven, Gradle, scripts, tests
    </li>
   </ul>
   <p>
    Stateless images can be created using a Dockerfile.
   </p>
  </div>
  <div class="mt-section" id="section_20" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Stateful">
   </span>
   <h4 id="3-3">
    Stateful
   </h4>
   <p>
    Components which are stateful are not necessarily harder to Dockerize. However, because the state of the component must be stored or synchronized with other instances, there are operational considerations to consider.
   </p>
   <p>
    Some examples of these are:
   </p>
   <ul>
    <li>
     <strong>
      Application servers with stateful applications
     </strong>
     — There is often a need to store user sessions in an application. Two approaches to handling this case are to use a load balancer with session affinity to ensure the user always goes to the same container instance or to use an external session persistence mechanism which all container instances share. There are also some components that provide native clustering such as portals or persistence layer caches. It is usually best to let the native software manage synchronization and state between instances. Having the instances on the same overlay network allows them to communicate with each other in a fast, secure way.
    </li>
    <li>
     <strong>
      Databases
     </strong>
     — Databases usually need to persist data on a filesystem. The best practice is to only containerize the Engine and not the data itself. This can be done using a host volume, for example:
     <pre>
<code>docker run -dit -v /var/myapp/data:/var/lib/postgresql/data postgres</code></pre>
    </li>
    <li>
     <strong>
      Applications with shared filesystems
     </strong>
     - Content Management Systems (CMS) use filesystems to store documents such as PDFs, pictures, Word files, etc. This can also be done using a host volume which is often mounted to a shared filesystem so several instances of the CMS can access the files simultaneously.
    </li>
   </ul>
   <p>
    Stateful images can usually be created using a Dockerfile.
   </p>
  </div>
  <div class="mt-section" id="section_21" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Complex_Product_Installation">
   </span>
   <h4 id="3-4">
    Complex Product Installation
   </h4>
   <p>
    Components that have a complex production installation are usually the hardest to Dockerize because they cannot be captured in a Dockerfile.
   </p>
   <p>
    Some examples of these are:
   </p>
   <ul>
    <li>
     <strong>
      Non-scriptable installation
     </strong>
     — These can include GUI-only installation/configuration or products that require multi-factor authentication.
    </li>
    <li>
     <strong>
      Non-idempotent installation process
     </strong>
     — Some installation processes can be asynchronous where the installation script has terminated but then starts background processes. The completion of the entire installation process includes waiting for a batch process to run or a cluster to synchronize without returning a signal or clear log message.
    </li>
    <li>
     <strong>
      Installation with external dependencies
     </strong>
     — Some products require an external system to reply for downloading or activation. Sometimes for security reasons this can only be done on a specific network or for a specific amount of time making it difficult to script the installation process.
    </li>
    <li>
     <strong>
      Installation that requires fixed IP address
     </strong>
     — Some products require a fixed IP address for a callback at install time but can then be configured once installed to use a hostname or DNS name. Since container IP address are dynamically generated, the IP address could be difficult to determine at build time.
    </li>
   </ul>
   <p>
    These cases should be done by running a container, installing the product, and then saving the changes to an image. For example:
   </p>
   <pre>
<code> $ docker commit -a "John Smith" -m "Installed CMS" mycontainer cms:2
</code></pre>
   <blockquote>
    <p>
     <strong>
      Tip
     </strong>
     : Tools or Test Container. When debugging services that have dependencies on each other, it is often helpful to create a container with tools to test connectivity or the health of a component. Common cases are network tools like telnet, netcat, curl, wget, or SQL clients, logging agents. This avoids adding unnecessary debugging tools to the containers that run the production loads.
    </p>
   </blockquote>
  </div>
 </div>
 <div class="mt-section" id="section_22" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="What_to_Include_in_an_Image">
  </span>
  <h3 id="2-9">
   What to Include in an Image
  </h3>
  <p>
   In the trend towards microservices, another question that arises is what components of an application stack to put in an image. You can include an entire application stack such as the the official GitLab image (
   <a class="link-https" href="https://hub.docker.com/r/gitlab/gitlab-ce/" rel="freeklink" title="https://hub.docker.com/r/gitlab/gitlab-ce/">
    https://hub.docker.com/r/gitlab/gitlab-ce/
   </a>
   ), or you can do the opposite, which would be to break up an existing monolithic application into microservices each residing in its own image.
  </p>
  <div class="mt-section" id="section_23" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Image_Granularity">
   </span>
   <h4 id="3-5">
    Image Granularity
   </h4>
   <p>
    In general, the best practice is to have one component per image. For example, a reverse proxy, an application server, or a database engine would each have its own image. What about an example where several web applications (war) are deployed on the same application server? Should they be separated and each have its own image or should they be in the same image? The criteria for this decision are similar to non-containerized architectural decisions:
   </p>
   <ul>
    <li>
     <strong>
      Release Lifecycle
     </strong>
     — Are the war release schedules tightly coupled or are they independent?
    </li>
    <li>
     <strong>
      Runtime Lifecycle
     </strong>
     — If one war stops functioning should all wars be stopped?
    </li>
    <li>
     <strong>
      Scalability
     </strong>
     — Do the wars need to be scaled separately or can they be scaled together?
    </li>
    <li>
     <strong>
      Security
     </strong>
     — Does one war need a higher level of security such as TLS?
    </li>
    <li>
     <strong>
      High Availability
     </strong>
     — Is one war mission critical needing redundancy and the others can tolerate a single point of failure and downtime?
    </li>
   </ul>
   <p>
    Similarly with microservices, the same criteria apply. For example, consider a microservice that depends on a logging agent to push logs to a centralized logging database. The following diagram shows two different strategies for a high availability deployment for the microservice.
   </p>
   <p>
    <img alt="Image Granularity" class="internal" src="/kb/images/1885-5.png"/>
   </p>
   <p>
    If the microservice and logging agent are loosely coupled, they can be run in separate containers such as in the configuration on the left. However, if the service and the logging agent are tightly coupled and their release lifecycles are identical, then putting the two processes in the same container can simplify deployments and upgrades as illustrated in the configuration on the right. To manage multiple processes there are several lightweight init systems for containers such as dumb-init and runit.
   </p>
  </div>
  <div class="mt-section" id="section_24" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Hardening_Images">
   </span>
   <h4 id="3-6">
    Hardening Images
   </h4>
   <p>
    A question that arises frequently is which parts of the component should go into an image? The engine or server, the application itself, the configuration files? There are several main approaches:
   </p>
   <ul>
    <li>
     Create only a base image and inject the things that vary per release or environment
    </li>
    <li>
     Create an image per release and inject the things that vary per environment
    </li>
    <li>
     Create an image per release and environment
    </li>
   </ul>
   <p>
    In some cases, a component does not have an application associated with it or its configuration does not vary per environment, so a base image is appropriate. An example of this might be a reverse proxy or a database. In other cases such as an application which requires an application server, using a base image would require mounting a volume for a certain version of an application.
   </p>
   <p>
    The following table summarizes the advantages and disadvantages of each choice:
   </p>
   <table>
    <thead>
     <tr>
      <th>
      </th>
      <th>
       <strong>
        Base Image
       </strong>
      </th>
      <th>
       <strong>
        Release Image
       </strong>
      </th>
      <th>
       <strong>
        Environment Image
       </strong>
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       What's inside the image
      </td>
      <td>
       OS, middleware, dependencies
      </td>
      <td>
       Base image, release artifacts, configuration
       <strong>
        generic
       </strong>
       to the environment
      </td>
      <td>
       Release image, configuration
       <strong>
        specific
       </strong>
       to the environment
      </td>
     </tr>
     <tr>
      <td>
       What's outside the image
      </td>
      <td>
       Release artifacts, configuration, secrets
      </td>
      <td>
       Configuration
       <strong>
        specific
       </strong>
       to the environment, secrets
      </td>
      <td>
       Secrets
      </td>
     </tr>
     <tr>
      <td>
       Advantages
      </td>
      <td>
       Most flexible at run time, simple, one image for all use cases
      </td>
      <td>
       Some flexibility at run time while securing a specific version of an application
      </td>
      <td>
       Most portable, traceable, and secure as all dependencies are in the image
      </td>
     </tr>
     <tr>
      <td>
       Disadvantages
      </td>
      <td>
       Less portable, traceable, and secure as dependencies are not included in the image
      </td>
      <td>
       Less flexible, requires management of release images
      </td>
      <td>
       Least flexible, requires management of many images
      </td>
     </tr>
     <tr>
      <td>
       Examples
      </td>
      <td>
       Tomcat (dtr.example.com/base/tomcat7:3)
      </td>
      <td>
       Tomcat + myapp-1.1.war (dtr.example.com/myapp/tomcat7:3)
      </td>
      <td>
       Tomcat + myapp-1.1.war + META-INF/context.xml (dtr.example.com/myapp/tomcat7:3-dev)
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    Usually a good choice is to use a release image. This gives the best combination of a sufficiently immutable image while maintaining the flexibility of deploying to different environments and topologies. How to configure the images per different environments is discussed later in the
    <a class="mt-self-link" href="#ConfigurationManagement" rel="internal">
     Configuration Management
    </a>
    section.
   </p>
  </div>
 </div>
 <div class="mt-section" id="section_25" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Image_Hierarchy">
  </span>
  <h3 id="2-10">
   Image Hierarchy
  </h3>
  <p>
   Docker images natively provide inheritance. One of the benefits of deriving from base images is that any changes to a base or upstream image are inherited by the child image simply by rebuilding that image without any change to the child Dockerfile. By using inheritance, an enterprise can very simple enforce policies with no changes to their many applications’ Dockerfiles. Typically, an enterprise will develop a hierarchy of base images depending on how diverse their technology stacks are. The following is an example of an image hierarchy.
  </p>
  <p>
   <img alt="Image Hierarchy" class="internal" src="/kb/images/1885-6.png"/>
  </p>
  <p>
   On the left are the enterprise-wide base images typically provided by the global operations team, and on the right are the application images. Even on the application side, depending on how large an application or program is, there can be a hierarchy as well.
  </p>
  <blockquote>
   <p>
    <strong>
     Tip:
    </strong>
    Create a project base image. In a project team with a complicated application stack there are often common libraries, tools, configurations, or credentials that are specific to the project but not useful to the entire enterprise. Put these items in a "project base image" from which all project images derive.
   </p>
  </blockquote>
  <p>
   <a name="ConfigurationManagement">
   </a>
  </p>
 </div>
 <div class="mt-section" id="section_26" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Configuration_Management">
  </span>
  <h3 id="2-11">
   Configuration Management
  </h3>
  <p>
   A single enterprise application will typically have four to twelve environments to deploy on before going into production. Without Docker installing, configuring, and managing these environments, a configuration management system such as Puppet, Chef, Salt, Ansible, etc. would be used. Docker natively provides mechanisms through Dockerfiles and
   <code>
    docker-compose
   </code>
   files to manage the configuration of these environments as code, and thus can be handled through existing version control tools already used by development teams.
  </p>
  <div class="mt-section" id="section_27" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Environment_Topologies">
   </span>
   <h4 id="3-7">
    Environment Topologies
   </h4>
   <p>
    The topologies of application environments can be different in order to optimize resources. In some environments it doesn't make sense to deploy and scale all of the components in an application stack. For example, in functional testing only one instance of a web server is usually needed whereas in performance testing several instances are needed, and the configuration is tuned differently. Some common topologies are:
   </p>
   <ul>
    <li>
     <strong>
      Development
     </strong>
     — A single instance per component, debug mode
    </li>
    <li>
     <strong>
      Integration, Functional testing, UAT, Demonstration
     </strong>
     - A single instance per component, small dataset, and integration to test external services, debug mode
    </li>
    <li>
     <strong>
      Performance Testing
     </strong>
     — Multiple instances per component, large dataset, performance tuning
    </li>
    <li>
     <strong>
      Robustness Testing
     </strong>
     — Multiple instances per component, large dataset, integration to test external services, batch processing, and disaster recovery, debug mode
    </li>
    <li>
     <strong>
      Production and Staging
     </strong>
     — Multiple instances per component, production dataset, integration to production external services, batch processing, and disaster recovery, performance tuning
    </li>
   </ul>
   <p>
    The configuration of components and how they are linked to each other is specified in the
    <code>
     docker-compose
    </code>
    file. Depending on the environment topology, a different
    <code>
     docker-compose
    </code>
    can be used. The
    <a class="link-https" href="https://docs.docker.com/compose/extends/#extending-services" rel="external nofollow" target="_blank">
     extends
    </a>
    feature can be used to create a hierarchy of configurations. For example:
   </p>
   <pre>
<code>myapp/
  common.yml &lt;- common configurations
  docker-compose-dev.yml &lt;- development environment specific configurations which extend common.yml
  docker-compose-int.yml
  docker-compose-prod.yml
</code></pre>
  </div>
  <div class="mt-section" id="section_28" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Configuration_Buckets">
   </span>
   <h4 id="3-8">
    Configuration Buckets
   </h4>
   <p>
    In a typical application stack there are tens or even hundreds of properties to configure in a variety of places. When building images and running containers or services there are many choices as to where and when a property should be set depending on how that property is used. It could be in a Dockerfile,
    <code>
     docker-compose
    </code>
    file, environment variable, environment file, property file, entry point script, etc. This can quickly become very confusing in a complicated image hierarchy especially when trying to adopt DRY principles. The following table shows some common groupings based on lifecycles to help determine where to put configurations.
   </p>
   <table>
    <thead>
     <tr>
      <th>
       <strong>
        When
       </strong>
      </th>
      <th>
       <strong>
        What
       </strong>
      </th>
      <th>
       <strong>
        Where
       </strong>
      </th>
      <th>
       <strong>
        Examples
       </strong>
      </th>
     </tr>
    </thead>
    <tbody>
     <tr>
      <td>
       Yearly build time
      </td>
      <td>
       Enterprise policies and tools
      </td>
      <td>
       Enterprise base image Dockerfiles
      </td>
      <td>
       <code>
        FROM centos6.6
       </code>
       <br/>
       <code>
        RUN yum -y --noplugins install bzip2 tar sudo
       </code>
       <br/>
       <code>
        curl net-tools
       </code>
      </td>
     </tr>
     <tr>
      <td>
       Monthly build time
      </td>
      <td>
       Application policies and tools
      </td>
      <td>
       Application base image Dockerfiles
      </td>
      <td>
       <code>
        COPY files/dynatrace-agent-6.1.0.7880-unix.jar /opt/dynatrace/
       </code>
      </td>
     </tr>
     <tr>
      <td>
       Monthly/weekly build time
      </td>
      <td>
       Application release
      </td>
      <td>
       Release image Dockerfiles
      </td>
      <td>
       <code>
        COPY files/MY_APP_1.3.1-M24_1.war /opt/jboss/standalone/deployments/
       </code>
      </td>
     </tr>
     <tr>
      <td>
       Weekly/daily deploy time
      </td>
      <td>
       Static environment configuration
      </td>
      <td>
       Environment variables, docker-compose, .env
      </td>
      <td>
       <code>
        environment:
       </code>
       <br/>
       -
       <code>
        MOCK=true
       </code>
       <br/>
       -
       <code>
        GATEWAY_URL=
        <a class="link-https" href="https://example.com/ws" rel="freeklink" title="https://example.com/ws">
         https://example.com/ws
        </a>
       </code>
      </td>
     </tr>
     <tr>
      <td>
       Deploy time
      </td>
      <td>
       Dynamic environment configuration
      </td>
      <td>
       Secrets, entrypoint.sh, vault, CLI, volumes
      </td>
      <td>
       <code>
        $ curl -H "X-Vault-Token: f3b09679-3001-009d-2b80-9c306ab81aa6" -X GET
        <a class="link-https" href="https://vlt.example.com:8200/v1/secret/db" rel="freeklink" title="https://vlt.example.com:8200/v1/secret/db">
         https://vlt.example.com:8200/v1/secret/db
        </a>
       </code>
      </td>
     </tr>
     <tr>
      <td>
       Run time
      </td>
      <td>
       Elastic environment configuration
      </td>
      <td>
       Service discovery, profiling, debugging, volumes
      </td>
      <td>
       <code>
        $ consul-template -consul consul.example.com:6124 \
       </code>
       <br/>
       <code>
        -template "/tmp/nginx.ctmpl:/var/nginx/nginx.conf:service nginx restart"
       </code>
      </td>
     </tr>
    </tbody>
   </table>
   <p>
    The process of figuring out where to configure properties is very similar to code refactoring. For example, properties and their values that are identical in child images can be abstracted into a parent image.
   </p>
  </div>
  <div class="mt-section" id="section_29" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Secrets_Management">
   </span>
   <h4 id="3-9">
    Secrets Management
   </h4>
   <p>
    Starting with Docker 17.03 (and Docker CS Engine 1.13), native
    <a href="https://success.docker.com/Architecture/Docker_Reference_Architecture%3A_Securing_Docker_EE_and_Security_Best_Practices" rel="internal">
     secrets management
    </a>
    is supported. Secrets can be created and managed using RBAC in Docker EE. Although Docker EE can manage all secrets, there might already be an existing secrets management system, or there might be the requirement to have one central system to manage secrets in Docker and non-Docker environments. In these cases, a simple strategy to adopt for Docker environments is to create a master secret managed by Docker EE which can then be used in an entry point script to access the exiting secrets management system at startup time. The recovered secrets can then be used within the container.
   </p>
  </div>
 </div>
 <div class="mt-section" id="section_30" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
  <span id="Dockerfile_Best_Practices">
  </span>
  <h3 id="2-12">
   Dockerfile Best Practices
  </h3>
  <p>
   As the enterprise IT landscape and the Docker platform evolve, best practices around the creation of Dockerfiles have emerged. Docker keeps a list of best practices on
   <a class="link-https" href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" rel="external nofollow" target="_blank">
    docs.docker.com
   </a>
   .
  </p>
  <div class="mt-section" id="section_31" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Docker_Files_and_Version_Control">
   </span>
   <h4 id="3-10">
    Docker Files and Version Control
   </h4>
   <p>
    Docker truly allows the concept of "Infrastructure as Code" to be applied in practice. The files that Docker uses to build, ship, and run containers are text-based definition files and can be stored in version control. There are different text-based files related to Docker depending on what they are used for in the development pipeline.
   </p>
   <ul>
    <li>
     <strong>
      Files for creating images
     </strong>
     — Dockerfiles,
     <code>
      docker-compose.yml
     </code>
     ,
     <code>
      entrypoint.sh
     </code>
     , and configuration files
    </li>
    <li>
     <strong>
      Files for deploying containers or services
     </strong>
     —
     <code>
      docker-compose.yml
     </code>
     , configuration files, and run scripts
    </li>
   </ul>
   <p>
    These files are used by different teams from development to operations in the development pipeline. Organizing them in version control is important to have an efficient development pipeline.
   </p>
   <p>
    If you are using a "release image" strategy, it can be a good idea to separate the files for building images and those used for running them. The files for building images can usually be kept in the same version control repository as the source code of an application. This is because release images usually follow the same lifecycle as the source code.
   </p>
   <p>
    For example:
   </p>
   <pre>
<code>myapp/
  src/
  test/
  Dockerfile
  docker-compose.yml &lt;- build images only
  conf/
    app.properties
    app.xml
    entrypoint.sh
</code></pre>
   <blockquote>
    <p>
     <strong>
      Tip:
     </strong>
     A
     <code>
      docker-compose
     </code>
     file with only
     <code>
      [build](
      <a class="link-https" href="https://docs.docker.com/compose/compose-file/#build" rel="freeklink" title="https://docs.docker.com/compose/compose-file/#build">
       https://docs.docker.com/compose/compose-file/#build
      </a>
      )
     </code>
     configurations for different components in an application stack can be a convenient way build the whole application stack or individual components in one file.
    </p>
   </blockquote>
   <p>
    The files for running containers or services follow a different lifecycle, so they can be kept in a separate repository. In this example, all of the configurations for the different environments are kept in a single branch. This allows for very simple version control strategy and viewing configurations for all environments is in one place.
   </p>
   <p>
    For example:
   </p>
   <pre>
<code>myapp/
  common.yml
  docker-compose-dev.yml
  docker-compose-int.yml
  docker-compose-prod.yml
  conf/
    dev.env
    int.env
    prod.env
</code></pre>
   <p>
    However, this single branch strategy quickly becomes difficult to maintain when different environments need to deploy different versions of an application. A better strategy is to have each environment's run configuration is in a separate branch. For example:
   </p>
   <pre>
<code>myapp/ &lt;- int branch
  docker-compose.yml
  conf/
    app.env
</code></pre>
   <p>
    The advantages of this are multiple:
    <em>
     Tags per release can be placed on a branch, allowing an environment to be easily rolled back to any prior tag.
    </em>
    Listing the history of changes to the configuration of a single environment becomes trivial. * When a new application release requires the same modification to all of the different environments and configuration files, it can be done using the merge function from the version control as opposed to copying and pasting the changes into each configuration file.
   </p>
  </div>
  <div class="mt-section" id="section_32" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
   <span id="Repositories_for_Large_Files">
   </span>
   <h4 id="3-11">
    Repositories for Large Files
   </h4>
   <p>
    When building Docker images inevitably there will be large binary files that need to be used. Docker build does not let you access files outside of the context path, and it is not a good idea to store these directly in a version control, especially a distributed one such as git, as the repositories will rapidly become too large and unwieldy.
   </p>
   <p>
    There are several strategies for storing large files:
   </p>
   <ul>
    <li>
     <strong>
      Web Server
     </strong>
     — They can be stored on a shared filesystem, served by a web server, and then accessed by exposing them with the
     <code>
      ADD &lt;URL&gt; &lt;dest&gt;
     </code>
     command in the Dockerfile. This is the easiest method to setup, but there is no support for versions of files or RBAC on files.
    </li>
    <li>
     <strong>
      Repository Manager
     </strong>
     — They can be stored as files in a repository manager such as Nexus or Artifactory, which provide support for versions and RBAC.
    </li>
    <li>
     <strong>
      Centralized Version Control
     </strong>
     — They can be stored as files in a centralized version control system such as SVN, which eliminates the problem of pulling all versions of large binary files.
    </li>
    <li>
     <strong>
      Git Large File Storage
     </strong>
     — They can be stored using Git LFS. This gives you all of the benefits of git, and the Docker build is under one context. However, there is a learning curve to using Git LFS.
    </li>
   </ul>
  </div>
 </div>
</div>
<div class="mt-section" id="section_33" mt-section-origin="Architecture/Docker_Reference_Architecture:_Development_Pipeline_Best_Practices_Using_Docker_EE">
 <span id="Summary">
 </span>
 <h2 id="1-7">
  Summary
 </h2>
 <p>
  This document discusses the Docker development pipeline, integration with existing systems, different workflows (developer, CI/CD, operations), applications to Dockerize, image granularity, configuration management, configuration buckets, and version control. Follow these best practices to create an effective enterprise development pipeline.
 </p>
 <p>
  <em>
   Document Version: 1.0
  </em>
 </p>
 <p>
  <em>
   Tested on: Docker EE 17.03, Docker Engine 1.13, DTR version 2.2.1, UCP 2.1.0
  </em>
 </p>
</div>
{% endraw %}
